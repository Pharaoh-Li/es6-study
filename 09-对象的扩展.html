<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body></body>
  <script src="./test.js"></script>
  <script>
    //1、属性的简洁表示法
    // const obj = {
    //     f() {
    //         console.log(this);
    //     }
    // }
    // obj.f()

    //2、属性名表达式
    // const obj = {}
    // obj.foo = true;
    // obj['a' + 'bc'] = 'abc'
    // console.log(obj);

    // const lastWord = 'last word'
    // const obj = {
    //     'first word': 'hello',
    //     [lastWord]: 'word',
    //     ['he' + 'llo'] () {
    //         console.log('hello');
    //     }
    // }
    // console.log(obj['first word']);
    // console.log(obj['last word']);
    // console.log(obj[lastWord]);
    // obj.hello()

    // const foo = 'bar'
    // const obj = {[foo]:foo}
    // console.log(obj);

    // const obj = { name: '1' }
    // const obj2 = { name: '1' }
    // const a = { [obj]: 1, [obj2]: 2 }
    // console.log(a); //{[object Object]: 2}

    //3、方法的 name 属性
    // const person = {
    //     sayName() {
    //         console.log('hello');
    //     },
    //     a: function www() {
    //         console.log('asd');
    //     }
    // }
    // function abc() {
    //     console.log('hello');
    // }
    // console.log(person.sayName.name); //sayName
    // console.log(person.a.name); //www
    // console.log(abc.name); //abc

    // const obj = {
    //     get foo() {},
    //     set foo(x) {},
    // }
    // console.log(obj.foo); //undefined
    // const descriptor = Object.getOwnPropertyDescriptor(obj, 'foo')
    // console.log(descriptor);
    // console.log(descriptor.get.name); // get foo
    // console.log(descriptor.set.name); // set foo
    // console.log((new Function()).name); //anonymous
    // const doSomething = function() {
    //     console.log('doSomething ---');
    // }
    // console.log(doSomething.bind().name); // bound doSomething
    // const key1 = Symbol('this is key1')
    // const key2 = Symbol('')
    // const obj = {
    //     [key1] () {},
    //     [key2] () {},
    // }
    // console.log(obj[key1].name); //[this is key1]
    // console.log(obj[key2].name); //[]

    //4、属性的可枚举性和遍历
    //可枚举性
    // const obj = { foo: '123', name: 'jack' }
    // const foodes = Object.getOwnPropertyDescriptor(obj, 'foo')
    // const des = Object.getOwnPropertyDescriptors(obj)
    // console.log(foodes);
    // console.log(des);
    // console.log(Object.getOwnPropertyDescriptor(class {foo () {}}.prototype, 'foo'));

    //属性的遍历
    const symbolKey = Symbol("key");
    // const obj = {
    //     a: '1',
    //     b: '2',
    //     c: '3',
    //     d: '4',
    //     [symbolKey]: '1'
    // }
    //（1）for...in
    // for (const key in obj) {
    //     console.log(key);
    // }
    //（2）Object.keys(obj)
    // Object.keys(obj).forEach(v => {console.log(v);})
    //（3）Object.getOwnPropertyNames(obj)
    // Object.getOwnPropertyNames(obj).forEach(item => {
    //     console.log(item); // 'a', 'b', 'c', 'd'
    // })
    //（4）Object.getOwnPropertySymbols(obj)
    // Object.getOwnPropertySymbols(obj).forEach(item => {
    //     console.log(item); // symbolKey
    // })
    //（5）Reflect.ownKeys(obj)
    // Reflect.ownKeys(obj).forEach(item => {
    //     console.log(item); // 'a', 'b', 'c', 'd', symbolKey
    // })
    //以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。
    // 首先遍历所有数值键，按照数值升序排列。
    // 其次遍历所有字符串键，按照加入时间升序排列。
    // 最后遍历所有 Symbol 键，按照加入时间升序排列。
    // const obj = {
    //     [symbolKey]: 0,
    //     'b': 0,
    //     'a': 0,
    //     9: 0,
    //     4: 0,
    //     5: 0
    // }
    // Reflect.ownKeys(obj).forEach(item => {
    //     console.log(item); // '4', '5', '9', 'b', 'a', symbolKey
    // })

    //5、super 关键字
    // const proto = {
    //     name: 'proto',
    //     foo() {
    //         console.log(this.a);
    //     }
    // }
    // const obj = {
    //     name: 'jack',
    //     print() {
    //         console.log(super.name) //proto
    //         console.log(Object.getPrototypeOf(this).name); //proto
    //         console.log(this.name) //jack
    //     },
    //     foo() {
    //         console.log(Object.getPrototypeOf(this).name); //proto
    //         super.foo() //jack
    //     }
    // }
    // Object.setPrototypeOf(obj, proto)
    // obj.print()
    // obj.foo()
    //注意，super关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错。

    //6、对象的扩展运算符
    // Object.prototype[Symbol.iterator] = function* (){
    //     for (const key in this) {
    //         yield {[key]: this[key]}
    //     }
    // }
    // const obj = {
    //     0: '1',
    //     1: '2',
    //     2: '3',
    //     length: 3
    // }
    // console.log(Array.from(obj));
    // console.log(...obj);
    // const obj = { x: 1, y: 2, a: 3, b: 4 };
    // const { x, y, ...z } = obj
    // console.log(x);
    // const o1 = {
    //     a: 1
    // }
    // const o2 = {
    //     b: 2
    // }
    // o2.__proto__ = o1
    // const { ...o3 } = o2
    // console.log(o3);
    // const o = Object.create({x: 1, y: 2})
    // o.z = 3
    // const {x,y, ...newObj} = o
    // console.log(o); // {z: 3}
    // console.log(x); // 1
    // console.log(y); // 2
    // console.log(newObj); //{z: 3}

    //扩展运算符
    // const z = {a:3, b: 4}
    // const n = {...z}
    // const foo = {...['a', 'b', 'c']}
    // console.log(foo); //{0: 'a', 1: 'b', 2: 'c'}
    // console.log({...1}); //{}
    //上面代码中，扩展运算符后面是整数1，会自动转为数值的包装对象Number{1}。由于该对象没有自身属性，所以返回一个空对象。
    // console.log({...'hello'}); //{0: 'h', 1: 'e', 2: 'l', 3: 'l', 4: 'o'}
    // console.log([...'hello']); //['h', 'e', 'l', 'l', 'o']
    // class C {
    //   p = 12
    //   m() {
    //     console.log('m');
    //   }
    // }
    // const c = new C()
    // const clone = {...c}
    // console.log(c.p);
    // c.m()
    // console.log(clone.p);
    // // clone.m() //报错
    // console.log(clone);


    // function cloneDeep(o1, o2) {
    //   for(let k in o2) {
    //     if (typeof o2[k] === 'object') {
    //       o1[k] = {}
    //       cloneDeep(o1[k], o2[k])
    //     } else {
    //       o1[k] = o2[k]
    //     }
    //   }
    // }
    // const obj = {
    //   name: 'jack',
    //   a: {
    //     b: 1
    //   },
    //   f() {
    //     console.log(1);
    //   }
    // }
    // const clone1 = {
    //   __proto__: Object.getPrototypeOf(obj),
    //   ...obj
    // }
    // const clone2 = Object.assign(
    //   Object.create(Object.getPrototypeOf(obj)),
    //   obj
    // );
    // const clone3 = Object.create(
    //   Object.getPrototypeOf(obj),
    //   Object.getOwnPropertyDescriptors(obj)
    // )
    // const clone4 = JSON.parse(JSON.stringify(obj))
    // const newObj = {}
    // cloneDeep(newObj, obj)
    
    // obj.name = 'rose'
    // obj.a.b = 2
    // console.log(clone1);
    // console.log(clone2);
    // console.log(clone3);
    // console.log(clone4);
    // console.log(newObj);


    // const a = {}
    // const b = {}
    // const ab = { ...a, ...b };
    // 等同于
    // let ab = Object.assign({}, a, b);


    //7、AggregateError 错误对象
    // const error = new AggregateError([
    //   new Error('ERROR_11112'),
    //   new TypeError('First name must be a string'),
    //   new RangeError('Transaction value must be at least 1'),
    //   new URIError('User profile link must be https'),
    // ], 'Transaction cannot be processed')
    // try {
    //   throw error
    // } catch(e) {
    //   console.log(e instanceof AggregateError); // true
    //   console.log(e.message);                   // Transaction cannot be processed
    //   console.log(e.name);                      // "AggregateError"
    //   console.log(e.errors); 
    // }

    //8、Error 对象的 cause 属性
    // const actual = new Error('an error!', { cause: 'Error cause' });
    // actual.cause; // 'Error cause'
    // try {
    //   throw actual
    // } catch(e) {
    //   console.log(e.message);
    //   console.log(e.cause);
    // }
    
    
  </script>
</html>
